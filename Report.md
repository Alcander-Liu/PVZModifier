# 植物大战僵尸修改器 实验报告
软件63 刘家维 2016013246

软件61 董学昊 2016013228

## 1. 开发环境

操作系统：Windows 10

IDE：Visual Studio 2017

辅助工具：Cheat Engine 6.7

修改目标：植物大战僵尸 v1.0.0.1051

## 2. 实现原理

通过Cheat Engine修改器的筛选功能找出游戏运行时对应数据与机器码的保存地址，在自己编写的汇编脚本中对运行中的游戏内存进行直接修改，以实现在运行中修改游戏的目标。

## 3. 实现方法与程序架构
所有源文件放置于`./PVZModifier/`下。

`main.asm`为程序入口，负责获取游戏窗口、进程ID。之后反复读取控制台输入的指令，判断调用对应函数。

`funcs.inc`用来声明每个修改指令对应的函数。同时，因为没有直接使用`Irvine32.inc`(因为当中的`SmallWin.inc`会与`windows.inc`冲突)，所以对于每个要使用到的`Irvine32.lib`中的函数，都必须要先用`PROTO`声明一次。

每个修改指令对应的函数都独立写于不同`asm`文件中，文件名、指令名与函数名三者相同。

* #### 获取游戏进程句柄
先用`FindWindowA`来用窗口名称搜索游戏窗口。
再用`GetWindowThreadProcessId`获得游戏进程ID。最后由`OpenProcess`来打开窗口并获得进程句柄，之后对读且的操作都基于这个句柄。

* #### 读取内存数据
`ReadProcessMemory`: 给入基于句柄的偏移地址及所欲长度可读取该地址的数据。

* #### 读取内存数据
`WriteProcessMemory`: 给入基于句柄的偏移地址及所欲长度可复写该地址的数值。

## 4. 实现功能

* ##### 修改阳光数量 setSun

找到阳光在运行中的保存地址`6A9EC0+768+5560`，直接修改阳光数量。

* ##### 一键秒杀全屏僵尸 killAllZombies

由于游戏中某些关卡本身就有达到某种条件直接秒杀全屏僵尸的设定，所以我们认为僵尸中有一种条件可以触发是否被秒杀。通过CE我们可以找到僵尸属性中有一项数值，当设定为3时该僵尸会立即死亡。但是由于登场僵尸是从一个序列中随机生成很难被捕捉到，所以我们从第一个僵尸（不一定登场）开始循环一千次，将所有数值设定为3，可以实现一键秒杀场上僵尸。

* ##### 无敌豌豆 godBean

将豌豆射手的攻击力设为9999（樱桃炸弹伤害为1800），取消豌豆的冷却时间，取消豌豆所需要的阳光，可以实现让豌豆射手秒杀所有僵尸并且无限种植。

* ##### 免费植物 freePlants

通过CE修改器的反汇编，我们发现减少阳光是由一段`sub`代码实现，我们直接将这段代码改为`nop`并且修改对应的机器码，可以实现种植植物不减少阳光，也就是免费种植。

* ##### 重复种植 overlapPlants

由于毁灭菇弹坑不可种植其他植物，我们猜想是否有一个判定语句判断该位置可不可以种植植物。通过CE修改器捕捉到该判定语句，将其改为强制跳转，我们即可不进行判定在已经种植了植物的位置重复种植植物。

* ##### 无敌僵尸 invincibleZombies

上面的所有语句都是对玩家友好而设定，这一个功能我们试图实现一个无敌僵尸。通过直接跳转掉僵尸扣血的判定语句，实现僵尸受到攻击而不扣血，变成无敌僵尸。在与上面其他功能相结合使用时会非常有意思。

* ##### 冻结所有僵尸 freezeZombies

每个僵尸属性里有一个冻结属性判定，通过循环遍历将所有僵尸属性中的冻结属性改为冻结状态，可以一键冻结所有僵尸。

* ##### 魅惑所有僵尸 charmZombies

与上一项同理。

* ##### 一键选择冒险关卡 setLevel

进入关卡前可调用此命令，输入关卡目标（1-50为冒险关，50+为隐藏关）实现直接跳关的目的。若已经在关卡内不能跳转。

* ##### 自动收集阳光 autoCollect
  
每个阳光对象会在每一帧调用一个检测函数，若检测到被鼠标点击了，就跳转到捡起函数，将这个跳转的`je`改成`jmp`强制跳转到捡起函数，就实现了自动采集。

* ##### 无冷却 noCoolDown

通过CE捕捉到重置冷却的机制为冷却中的植物每帧给一个数字+1，当达到该植物冷却时间时重置为0，所以我们直接将该机器码改为每帧+9999，实现直接无冷却的机制。

* ##### 通关一周目 clearFirstRound
  将内存中`6A9EC0+82C+2C`设为1，通关第一周目。

## 5. 使用说明
可执行文件位于`./Release/PVZModifier.exe`
先运行游戏程序，然后运行此程序，可反复输入提示清单中的命令来修改游戏。

有些指令会提示玩家接着输入进一步的值，例如:
* setSun: 会接着提示家输入要将阳光设成多少
* setLevel: 会接着提示家输入要将关卡设成多少
* freezeZombies: 会接着提示家输入要将僵尸冻结多久
  
有些指令第一遍输入时是开启功能，再次输入则是关闭该功能，例如:
* overlapPlants
* freePlants
* invincibleZombies
* autoCollect
* noCoolDown

## 6. 难点

* ##### 偏移地址
植物大战僵尸中，虽然各个数据存放的地址是有固定规律的，但并非直接是在固定地址，而是经过固定的辗转偏移后可以获取固定的数据。例如先前我们将阳光数据的地址写为`6A9EC0+768+5560`，这只是简单写法，事实上以汇编语法来阳光值是`[[[6A9EC0h] + 768h] + 5560h]`，可以看出游戏后台存储数据是有多级指针与数组等结构存在。

这导致我们在探查特定数据的地址时比较艰难，因为即使在一局游戏中透多筛选数值变化，找到了一个数据的地址，在下一次进入游戏中，也已不是储存在同一个地址了，因只有偏移量是固定的，但这并不好找到。必须要反复观察哪些命令访问或复写了该地址，才能渐渐猜出规则。

* ##### 获取单个僵尸对象数据

一开始测试时我们发现一直捕捉不到场上的僵尸。内存中是存在一个很长的僵尸数据空间的，我们以为场上出现的僵尸是按照数据空间先后来决定的，所以当场上有四只僵尸时，我们原本只遍历数据空间中前四只僵尸，却一直无法匹配起来。后来通过研究发现僵尸的出现顺序并不按照数据顺序，而可能是后面的某一个空间中对应的僵尸，所以我们想出了两种不同方法，一个是从头开始遍历，每只都检查"存在属性"来确定该僵尸是否在场上存活着，是的话才计数，直到有效支数跟另一个数据显示的数量吻合，就退出循环，第二个方法是强行遍历1000个僵尸数据空间，对每个空间都重复一样操作，因为不在场上的即使被修改了也不会影响游戏进行。

* #### 自动采集

自动采集阳光、金币等等功能，是十分常见且经常需要的功能。一开始我们发现有一个0/1变量，当场上出现阳光时，他会被置1，只要这时我们将他置0，场上当前阳光就会全被收回。但只要又出现阳光，该变量又会变1。也就是此操作是单次性的，除非我们能做多线程，在独立线程中反复此操作，否则无法真的实现自动采集。

接着，我们的思路是，阳光被采集后，阳光值会增加，所以我们就去观察是谁修改了阳光值，只有采集阳光或种植植物会修改阳光值，所以这很好找出。这各修改阳光值的指令所在的函数，我发现它只有在我点击阳光后会触发，所以这个函数不是我们的最终目标，而是在外部调用这个函数的指令。

因为游戏机制应该是每祯时都会检测鼠标是否点击了阳光，若是，才调用这个捡起函数。所以我们要做的是找到调用捡起函数的位置，并修改它前面的判断鼠标点击语句，将它强制跳转到捡起函数。

所以我们顺着捡起函数的ret出口，找到了调用捡起函数的位置，姑且称它为检测函数，这个阳光的检测函数显然是每帧调用的，因为当我在函数开头打断点时，若场上有阳光存在，则会马上运行到这个断点而暂停，若无，则不会暂停。所以我们就在这个检测函数中、调用捡起函数前面的判断语句依依尝试，发现有一句je会跳转到捡起函数前面，如果将je改成jmp强制跳转，则阳光一出现后，该帧的检测函数就一定会跳转调用捡起函数，于是就实现了自动采集功能。

